Задача 1
===
Используя docker поднимите инстанс PostgreSQL (версию 13). Данные БД сохраните в volume.

Подключитесь к БД PostgreSQL используя `psql`.

Воспользуйтесь командой `\?` для вывода подсказки по имеющимся в `psql` управляющим командам.

**Найдите и приведите** управляющие команды для:

* вывода списка БД
* подключения к БД
* вывода списка таблиц
* вывода описания содержимого таблиц
* выхода из psql

Решение
---
* вывод списка БД - `\l`
* подключение к БД - `\c`
* вывод списка таблиц - `\dt`
* вывод описания содержимого таблиц - `\d`
* выход из psql - `\q`

Задача 2
===
Используя `psql` создайте БД `test_database`.

Изучите бэкап БД.

Восстановите бэкап БД в `test_database`.

Перейдите в управляющую консоль `psql` внутри контейнера.

Подключитесь к восстановленной БД и проведите операцию ANALYZE для сбора статистики по таблице.

Используя таблицу pg_stats, найдите столбец таблицы `orders` с наибольшим средним значением размера элементов в байтах.

**Приведите в ответе** команду, которую вы использовали для вычисления и полученный результат.

Решение
---
```
database=# SELECT MAX(avg_width) FROM pg_stats;
 max 
-----
 647
(1 row)
```

Задача 3
===
Архитектор и администратор БД выяснили, что ваша таблица orders разрослась до невиданных размеров и поиск по ней занимает долгое время. Вам, как успешному выпускнику курсов DevOps в нетологии предложили провести разбиение таблицы на 2 (шардировать на orders_1 - price>499 и orders_2 - price<=499).

Предложите SQL-транзакцию для проведения данной операции.

Можно ли было изначально исключить "ручное" разбиение при проектировании таблицы orders?

Решение
---

Транзакция:
```
begin;

create table orders_1 (
	check (price > 499)
) inherits orders 

create table orders_2 (
	check (price <= 499)
) inherits orders

create rule insert_1 as on insert to orders
where (price > 499)
do instead insert into orders_1 

create rule insert_2 as on insert to orders
where (price <= 499)
do instead insert into orders_2 

commit;
```
Во время проектирования таблицы orders при понимании того, что таблица будет большая, следует ее разделить на разные таблицы по какому-то одному признаку и записывать данные в них раздельно. Либо сразу прошардировать, как в примере выше. Тогда, при внесении данных в orders, они сразу будут разноситься по мелким таблицам.

Задача 4
===
Используя утилиту `pg_dump` создайте бекап БД `test_database`.

Как бы вы доработали бэкап-файл, чтобы добавить уникальность значения столбца `title` для таблиц `test_database`?

Решение
---
Команда для создания бэкапа:


`pg_dump -U postgres -d test_database > psql-data/my_test_dump.sql`

Для добавления уникальности можно добавить ограничение `UNIQUE` прямо в дамп. Например, так:
```
`CREATE TABLE public.orders (
    id integer NOT NULL,
    title character varying(80) NOT NULL,
    price integer DEFAULT 0,
  >>UNIQUE (title)
);
```