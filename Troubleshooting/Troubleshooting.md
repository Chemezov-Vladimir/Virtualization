Задача 1
=

Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит
CRUD операция в MongoDB и её нужно прервать.

Вы как инженер поддержки решили произвести данную операцию:

* напишите список операций, которые вы будете производить для остановки запроса 
пользователя
* предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

Решение
-

Сначала нужно найти `opid` операции через `db.currentOp()`, затем остановить процесс через
`db.killOp()`.

Для решения проблемы с долгими запросами в общих случаях хватит создать индекс. Еще может
помочь оптимизация конкретных запросов. 

Задача 2
=

Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.

Вы запустили инстанс Redis для использования совместно с сервисом, который использует 
механизм TTL. Причем отношение количества записанных key-value значений к количеству 
истёкших значений есть величина постоянная и увеличивается пропорционально количеству
реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:

* сначала рост отношения записанных значений к истекшим
* Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

Решение
-

По всей видимости, масштабирование до N реплик происходило в короткий промежуток 
времени, что вызвало лавину свежих записей. А потом, из-за большого количества 
значений с истекающим в один момент сроком, Redis стал блокировать операции записи.

Задача 3
=

Перед выполнением задания познакомьтесь с документацией по Common Mysql errors.

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества 
записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:
```
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```
Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

Решение
-

Документация говорит, что всего 4 вероятных причины этой ошибки.

Самая частая причина - это проблемы с сетью. Если эта ошибка возникает часто, то нужно 
проверять состояние сети.

Иногда такая ошибка возникает, когда одновременно на СУБД приходит миллионы строк из 
запросов. Если такая нагрузка присутствует, то стоит увеличить значение параметра 
`net_read_timeout`.

В редких случаях эта ошибка возникает при первоначальном соединении с сервером. 
Локализовать ее можно с помощью `SHOW GLOBAL STATUS LIKE 'Aborted_connects'`, чей рост
значений говорит об этой ошибке. Так же если в тексте ошибки содержится `reading 
authorization packet`, то проблема в этом. Для решения нужно увеличить параметр 
`connect_timeout`.

Если проблема не в этих трех случаях, то, возможно, проблема со значениями `BLOB`,
иногда она сопровождается ошибкой `ER_NET_PACKET_TOO_LARGE`. В таком случае нужно
увеличить значение `max_allowed_packet`.

Задача 4
=

Перед выполнением задания ознакомтесь со статьей Common PostgreSQL errors из блога 
Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в 
документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится
недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

Решение
-

Из-за недостатка RAM ОС начинает завершать процессы, не являющиеся системными. Для
решения этой проблемы нужно ограничить доступную PostgreSQL оперативную память либо
увеличить объем ОЗУ.